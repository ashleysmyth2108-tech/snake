<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>Van Dodger üöê ‚Äî HTML5 Canvas</title>
  <style>
    :root { --bg: #0f172a; --fg: #e2e8f0; --accent: #22d3ee; }
    html, body { height: 100%; margin: 0; background: #1e293b; color: var(--fg); font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, sans-serif; }
    .wrap { display: grid; place-items: center; min-height: 100%; padding: 12px; gap: 12px; }
    #game { width: min(95vw, 560px); height: calc(min(95vw, 560px) * 1.6); max-height: 85vh; border-radius: 16px; box-shadow: 0 20px 40px rgba(0,0,0,.35), inset 0 0 0 2px rgba(255,255,255,.06); background: linear-gradient(#6b7280, #374151); }
    .hud { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; justify-content: center; opacity: .9; }
    .btn { background: #0ea5e9; color: white; border: none; padding: 10px 14px; border-radius: 12px; font-weight: 700; letter-spacing: .3px; cursor: pointer; box-shadow: 0 6px 18px rgba(0,0,0,.25); }
    .btn:hover { filter: brightness(1.05); }
    .pill { padding: 8px 12px; border-radius: 999px; background: rgba(15,23,42,.5); border: 1px solid rgba(255,255,255,.08); }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; background: rgba(255,255,255,.1); padding: 2px 6px; border-radius: 6px; }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="game" width="350" height="560" aria-label="Van dodger canvas game"></canvas>
    <div class="hud">
      <span class="pill">Score: <strong id="score">0</strong></span>
      <span class="pill">Best: <strong id="best">0</strong></span>
      <button class="btn" id="startBtn">Start</button>
      <button class="btn" id="pauseBtn">Pause</button>
      <button class="btn" id="resetBtn">Reset</button>
    </div>
    <div class="pill" style="max-width: 900px; text-align:center">
      Tap / Click / <span class="kbd">Space</span> to drive ¬∑ <span class="kbd">P</span> pause ¬∑ <span class="kbd">R</span> restart
    </div>
  </div>

  <script>
  (()=>{
    const canvas = document.getElementById('game');
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const startBtn = document.getElementById('startBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const resetBtn = document.getElementById('resetBtn');

    function fitCanvasToCSS() {
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      const rect = canvas.getBoundingClientRect();
      canvas.width = Math.floor(rect.width * dpr);
      canvas.height = Math.floor(rect.height * dpr);
      return dpr;
    }

    let DPR = fitCanvasToCSS();
    const ctx = canvas.getContext('2d');

    const GRAVITY = 1500;
    const FLAP_V = -420;
    const PIPE_SPEED = -180;
    const PIPE_SPAWN = 1.45;
    const BASE_GAP = 160;
    const FLOOR_H = 90;

    const STATE = { READY: 'ready', PLAY: 'play', PAUSE: 'pause', OVER: 'over' };
    let state = STATE.READY;

    const world = {
      w: () => canvas.width / DPR,
      h: () => canvas.height / DPR,
      time: 0,
      lastSpawn: 0,
      score: 0,
      best: Number(localStorage.getItem('van_best') || 0),
    };

    bestEl.textContent = world.best;

    const van = {
      x: 100,
      y: 220,
      w: 50,
      h: 30,
      vy: 0,
      rot: 0,
    };

    const pipes = [];

    function resetGame(hard=false) {
      world.time = 0; world.lastSpawn = 0; world.score = 0; pipes.length = 0;
      van.x = Math.max(80, world.w()*0.28); van.y = world.h()*0.4; van.vy = 0; van.rot = 0;
      state = hard ? STATE.READY : STATE.PLAY;
      updateHUD();
    }

    function updateHUD() {
      scoreEl.textContent = world.score;
      bestEl.textContent = world.best;
      pauseBtn.textContent = state === STATE.PAUSE ? 'Resume' : 'Pause';
      startBtn.textContent = (state === STATE.READY || state === STATE.OVER) ? 'Start' : 'Restart';
    }

    function flap() {
      if (state === STATE.READY) { resetGame(); return; }
      if (state === STATE.OVER) { resetGame(); return; }
      if (state === STATE.PAUSE) { return; }
      van.vy = FLAP_V;
    }

    function currentGap() {
      const minGap = 110;
      return Math.max(minGap, BASE_GAP - world.score * 3);
    }
    function currentSpeed() {
      return PIPE_SPEED - world.score * 2;
    }

    function spawnPipe() {
      const gap = currentGap();
      const margin = 30;
      const maxTop = world.h() - FLOOR_H - margin - gap;
      const top = margin + Math.random() * Math.max(1, maxTop - margin);
      pipes.push({ x: world.w() + 40, top, gap, scored: false });
    }

    function aabbIntersect(ax, ay, aw, ah, bx, by, bw, bh) {
      return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
    }

    let lastT = performance.now();
    function loop(now) {
      requestAnimationFrame(loop);
      const dt = Math.min(1/30, (now - lastT) / 1000);
      lastT = now;
      if (state === STATE.PAUSE) { draw(); return; }
      if (state === STATE.READY) { draw(); return; }
      if (state === STATE.OVER)  { draw(); return; }

      world.time += dt;

      van.vy += GRAVITY * dt;
      van.y += van.vy * dt;
      van.rot = Math.atan2(van.vy, 300);

      if (world.time - world.lastSpawn > PIPE_SPAWN) {
        world.lastSpawn = world.time;
        spawnPipe();
      }

      for (let i = pipes.length - 1; i >= 0; i--) {
        const p = pipes[i];
        p.x += currentSpeed() * dt;
        if (!p.scored && p.x + 60 < van.x - van.w/2) {
          p.scored = true;
          world.score++;
          if (world.score > world.best) {
            world.best = world.score; localStorage.setItem('van_best', world.best);
          }
        }
        if (p.x < -120) pipes.splice(i, 1);
      }

      const vanBox = { x: van.x - van.w/2, y: van.y - van.h/2, w: van.w, h: van.h };
      for (const p of pipes) {
        const pipeW = 60;
        const topRect = { x: p.x, y: 0, w: pipeW, h: p.top };
        const botRect = { x: p.x, y: p.top + p.gap, w: pipeW, h: world.h() - FLOOR_H - (p.top + p.gap) };
        if (aabbIntersect(vanBox.x, vanBox.y, vanBox.w, vanBox.h, topRect.x, topRect.y, topRect.w, topRect.h) ||
            aabbIntersect(vanBox.x, vanBox.y, vanBox.w, vanBox.h, botRect.x, botRect.y, botRect.w, botRect.h)) {
          gameOver();
          break;
        }
      }

      if (van.y + van.h/2 > world.h() - FLOOR_H || van.y - van.h/2 < 0) {
        gameOver();
      }

      updateHUD();
      draw();
    }

    function gameOver() {
      state = STATE.OVER;
      updateHUD();
    }

    function draw() {
      const W = world.w(), H = world.h();
      ctx.save();
      ctx.scale(DPR, DPR);

      ctx.fillStyle = '#374151';
      ctx.fillRect(0,0,W,H);

      drawRoad(W,H);

      for (const p of pipes) {
        drawBarrier(p);
      }

      drawGround(W,H);
      drawVan();

      ctx.textAlign = 'center';
      ctx.font = '700 28px ui-sans-serif, system-ui, -apple-system, Segoe UI';
      ctx.fillStyle = 'rgba(15,23,42,.8)';
      ctx.fillRect(W/2 - 60, 12, 120, 40);
      ctx.fillStyle = '#e2e8f0';
      ctx.fillText(String(world.score), W/2, 40);

      if (state === STATE.READY) {
        banner('Tap / Click / Space to start');
      } else if (state === STATE.PAUSE) {
        banner('Paused ‚Äî press P to resume');
      } else if (state === STATE.OVER) {
        banner('Crashed! ‚Äî press R to restart');
      }

      ctx.restore();
    }

    function banner(text) {
      const W = world.w(), H = world.h();
      ctx.textAlign = 'center';
      ctx.font = '800 22px ui-sans-serif, system-ui, -apple-system, Segoe UI';
      ctx.fillStyle = 'rgba(15,23,42,.7)';
      const pad = 14; const tw = ctx.measureText(text).width;
      ctx.fillRect((W-tw)/2 - pad, H*0.35 - 28, tw + pad*2, 46);
      ctx.fillStyle = '#e2e8f0';
      ctx.fillText(text, W/2, H*0.35);
    }

    function drawBarrier(p) {
      const H = world.h();
      const pipeW = 60;
      ctx.fillStyle = '#1f2937';
      ctx.fillRect(p.x, 0, pipeW, p.top);
      ctx.fillRect(p.x, p.top + p.gap, pipeW, H - FLOOR_H - (p.top + p.gap));
    }

    function drawRoad(W,H) {
      ctx.fillStyle = '#111827';
      ctx.fillRect(0,0,W,H-FLOOR_H);
      ctx.strokeStyle = '#f9fafb';
      ctx.lineWidth = 4;
      ctx.setLineDash([20,20]);
      ctx.beginPath();
      ctx.moveTo(W/2,0);
      ctx.lineTo(W/2,H-FLOOR_H);
      ctx.stroke();
      ctx.setLineDash([]);
    }

    function drawGround(W,H) {
      ctx.fillStyle = '#065f46';
      ctx.fillRect(0, H - FLOOR_H, W, FLOOR_H);
    }

    function drawVan() {
      ctx.save();
      ctx.translate(van.x, van.y);
      ctx.rotate(Math.max(-0.3, Math.min(0.3, van.rot)));

      ctx.fillStyle = '#f87171';
      ctx.fillRect(-van.w/2, -van.h/2, van.w, van.h);
      ctx.fillStyle = '#1f2937';
      ctx.fillRect(-van.w/2, -van.h/2, van.w*0.3, van.h);
      ctx.fillStyle = '#93c5fd';
      ctx.fillRect(-van.w/2+van.w*0.3, -van.h/2+4, van.w*0.7-4, van.h-8);
      ctx.fillStyle = '#111827';
      ctx.beginPath();
      ctx.arc(-van.w/3, van.h/2, 6, 0, Math.PI*2);
      ctx.arc(van.w/3, van.h/2, 6, 0, Math.PI*2);
      ctx.fill();

      ctx.restore();
    }

    function togglePause() { if (state === STATE.PLAY) state = STATE.PAUSE; else if (state === STATE.PAUSE) state = STATE.PLAY; updateHUD(); }

    window.addEventListener('resize', ()=>{ DPR = fitCanvasToCSS(); });
    startBtn.addEventListener('click', ()=>{ if (state===STATE.READY||state===STATE.OVER) resetGame(); else resetGame(); });
    pauseBtn.addEventListener('click', togglePause);
    resetBtn.addEventListener('click', ()=>{ state = STATE.READY; resetGame(true); });

    document.addEventListener('keydown', (e)=>{
      if (e.code === 'Space' || e.code === 'ArrowUp' ) { e.preventDefault(); flap(); }
      else if (e.key.toLowerCase() === 'p') togglePause();
      else if (e.key.toLowerCase() === 'r') { state = STATE.READY; resetGame(true); }
    }, { passive: false });

    const pointerFlap = (e)=>{ e.preventDefault(); flap(); };
    canvas.addEventListener('pointerdown', pointerFlap, { passive: false });

    (function seed(){ for (let i=0;i<3;i++){ pipes.push({ x: 260 + i*140, top: 40 + i*40, gap: BASE_GAP, scored: true }); }})();
    draw();
    requestAnimationFrame(loop);
  })();
  </script>
</body>
</html>
